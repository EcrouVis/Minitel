Dump de la mémoire d'un minitel M12 Philips.
Le dump est en 4 parties car pour accéder à toute la mémoire de la ROM, le minitel n'a pas un bus de données assez large (processeur 80C32) et utilise donc 2 GPIOs (P1.0 et P1.1) pour changer de 'banque de données' et ainsi pouvoir lire toute la mémoire.

Notez que ce système a partiellement endommagé ma puce mémoire.
Les 2 entrées d'adresse gérées de manière externe par le circuit électronique et censées accepter un signal TTL se sont dégradées au point où 3.3V n'était plus considéré comme un 1 mais comme à un niveau indéfini!

Chaque banque semble formée de la même manière:

|---------------------------------------|
|Code d'initialisation/Reset            |
|Vecteurs d'interruption                |
|---------------------------------------|
|Code spécifique à la banque            |
|---------------------------------------|
|0xE000 - 0xE614:                       |
|Fonctions de saut vers d'autres banques|
|---------------------------------------|
|???                                    |
|---------------------------------------|

---------- Commun à toutes les banques ----------

Fonctions de saut de banque:

-vers p1:
  0xE2C0 - 0xE608
  105 fonctions

-vers p2:
  0xE000 - 0xE2C0
  88 fonctions

-vers p3:
  0xE608 - 0xE614
  1 fonction - lecteur de l'audio du répondeur minitel

-vers p4:
  rien

Exemple de fonction de saut (adresse 0xE000):

dump_Bz6_p1.bin:
  e000:
  SETB P1.0
  LCALL e000
  CLR P1.0
  RET

dump_Bz6_p2.bin:
  SETB P1.0
  LCALL 07fe
  CLR P1.0
  RET

---------- ROM partie 1 (dump_Bz6_p1.bin) ----------

En cours de décompilation

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut
  -d'autres fonctions

---------- ROM partie 2 (dump_Bz6_p2.bin) ----------

En cours de décompilation

Contient le protocole ?

Contient énormément d'instructions JMP

Il faut désactiver l'analyse des switch/case dans Ghidra et faire la décompilation des JMP manuellement pour ne pas avoir de problèmes lors de la décompilation.

---------- ROM partie 3 (dump_Bz6_p3.bin) ----------

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut
  -le lecteur audio
  -la piste audio

Code du lecteur audio:
  0x966B - 0x96B3

Audio du répondeur minitel:
  0x01D1 - 0x9542
  Audio sous forme PWM puis filtré (passe bande 300-3400Hz pour la téléphonie)
  Le bit de poids fort est lu en premier
  L'oscillateur a une période de 14.7456MHz
  1 bit est joué toutes les 27.5*12 périodes en moyenne

Code non utilisé:
  0x0008 - 0x000A:
    Fin des données audio

  0x9542 - 0x95E2

  0x96D3 - 0x96E8
    Copie la ROM (partie 3 seulement) dans la RAM externe puis s'arrête (boucle infinie)

  0xFFAD - 0xFFF1
    Checksum sur 16 bit de la ROM entière puis envoi le résultat quelque part en base 16

---------- ROM partie 4 (dump_Bz6_p4.bin) ----------

Ne semble pas être utilisée

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut

Code non utilisé:
  0x01D1 - 0x0271

  0x031A - 0x032F
    Copie la ROM (partie 4 seulement) dans la RAM externe puis s'arrête (boucle infinie)

  0xFFAD - 0xFFF1:
    Checksum sur 16 bit de la ROM entière puis envoi le résultat quelque part en base 16



---------- Partage du bus de données entre la ROM, la RAM, la puce vidéo et le CPLD MBSL-4000FH5-5 ----------

Quand P1.5=1, la ROM et la RAM externe sont accédées de manière normale. On peut supposer que le CPLD fait office de tampon pour les 8 bits de poids fort de l'adresse.

Quand P1.5=0, la puce vidéo est virtuellement montée aux adresses 0xXX20 à 0xXX2F à la place de la RAM externe. On peut supposer que les autres entrées sorties du CPLD peuvent être accédées de la même manière mais à d'autres adresses.

De potentielles adresses (en recherchant la séquence 0xC2 0x95 - CLR P1.5 dans la ROM partie 1 et 2) utilisées pour communiquer avec le CPLD sont:
0x0040
0x0041
0x0042
0x0048
0x0050
0x0051
0x0052
0x0053
0x0070



---------- Sauts indirects ----------
JMP @A+DPTR

ROM partie 2 adresse 0x6792 (juste pourquoi ne pas utiliser JMP @A+DPTR ???):
F_JMP:
  RL A
  MOV R0, A
  INC R0
  MOVC A, @A+DPTR
  PUSH A
  MOV A, R0
  MOVC A, @A+DPTR
  PUSH A
  RET
Les fonctions qui utilisent ce type de saut sont:
-p1: 0x9A5A, 0xB04B, 0xB0B6
-p2: 0x675D, 0x6792

Une implémentation qui pourrai complexifier le code comme ci-dessous n'as pas encore été trouvée:
POP X
…
POP Y
…
RET



---------- Emulation de la liaison série microcontrôleur - modem ----------
RX:

Le timer augmente de 1 à une fréquence de f_osc/12 et déborde à une fréquence de f_osc/12/256
Cela donne une vitesse de réception de f_osc/(i2C.5?196608:12288) bauds (soit 75/1200 bauds avec un oscillateur de 14.7456MHz)

Forme du message: 1 start bit + 8 bits + 2 stops bits

Variables gérées en interne:
i7D: x bits restants
i7B: pause x cycle
i7C: message en cours de réception
i26.5: message détecté
i26.6: réessayer de réceptionner le message si erreur sur le premier bit stop

Variables de contrôle de la réception:
i75: message non lu reçu
i76: message non lu reçu précédent
i2C.5: vitesse de réception 0: 1200 bauds / 1: 75 bauds
i22.0: message présent
i22.1: quel message à écraser en cas de nouvelle réception 0: nouveau / 1: ancien
i29.3: message précédent écrasé

MAIN
  TMOD=0x23 //timer 1: 8-bit contrôlé par TH0 (timer 0 en mode 3) avec rechargement automatique / timer 0: 8-bit
  TCON=0x50

IE1
  if INT1 return
  clear EX1 //désactivation de l'interruption
  TH0=0x0F //ajustement de la valeur de départ du timer
  clear TF1 //remise à zéro de l'interruption du timer
  set ET1 //activation du timer
  set i26.5 //initialisation de la réception du message
  set i26.6
  i7D=8
  i7B=2
  if i2C.5 //dans le cas de la réception à 75 bauds
    TH0=0x13
    i7B=0x20
  return

IT1
  i7B-=1
  if i7B>0 return //attends le prochain bit
  i7B=4 //prochain bit dans 4 cycles
  if i2C.5 i7B=0x40
  if i26.5 //dans le cas où un message est détecté
    i7C=(i7C>>1)|(INT1?0x80:0)
    i7D-=1
    if i7D==0:
      clear i26.5 //fin du message
    return
  if i26.6
    clear i26.6
    if not INT1 //erreur dans la réception du premier bit stop, réessayer
      set i26.5
      return
  else
    if INT1 //transfert du message + flags
      if i22.1
        i76=i75
        set i29.3
      else
        set i22.1
      i75=i7C
      set i22.0
  clear ET1 //désactivation du timer
  set EX1 //activation de l'interruption
  return

TX:

L'utilisation d'IT0 est partagé avec une autre fonction qui n'est pas pris en compte ci-dessous pour plus de simplicité

Variables gérées en interne:
i7A: compteur pause x cycles (4800->1200 cycles par secondes)
i7E: compteur division des cycles par x (1200->75 cycles par secondes)
i78: message en cours d'émission

Variables de contrôle de l'émission:
i24.6: émission du message en cours
i24.7: message non envoyé présent
i26.3: émission du message quand 0
i26.4: message à envoyer présent
i26.0,i26.1,i26.2: x bits envoyés
i28.0: vitesse d'émission 0: 75 bauds / 1: 1200 bauds
i79: message à envoyer

MAIN
  TMOD=0x23
  TCON=0x50

F_TX //dans la partie 2 de la ROM à l'adresse 0x70C6
  i79=A //message à envoyer
  set i24.7 //message présent
  if not i24.6 //réinitialisation des variables
    i26|=0x18
  set i24.6

IT0
  i7A-=1
  if i7A>0 return
  i7A=4
  if not i24.6 return
  if not 28.0 //dans le cas d'un envoi à 75 bauds
    i7E-=1
    if i7E return //ne laisser passer qu'un cycle sur 16 (1200/75=16)
    i7E=0x10
  if i26.3
    clear i26.3
    if i26.4
      clear i26.4
      i78=i79
      clear i24.7
      clear P1.3 //start bit
      return
    i26|=0x18
    if not i24.7
      set P1.3 //stop bit
      clear i24.6
      return
  else
    A=(i78>>1)|(i78<<7)&0xFF
    i26+=1
    B=i78&0x01
    i78=A
    if B: //envoi d'un bit du message
      set P1.3
    else
      clear P1.3

Changement de vitesse:






















---------- mémoire externe ----------
0x06AA-0x06B1 - copie des registres du modem

0x06D5 - état du clavier ?
0x06D6 - mémoire temporaire vers le clavier ?
0x06D7 - mémoire temporaire depuis le clavier (premier octet du message reçu) ?

---------- mémoire interne ----------
0x28 - copie de l'état des IO du CPLD (sans le bit 6) ?
0xAD - copie de l'entrée clavier
0xAC - message pour le clavier

0x56, 0x57, 0x58, 0x2E, 0x2F - gestion des données / commandes / variables temporaires (0x2E, 0x2F: modifiable bits par bits) ?

---------- communication avec le clavier ----------
Fonction de vérification du message à l'adresse 0x1CC16 (code partie 2, adresse 0xCC16) 

Communication série avec des messages de 2 octets (o1 et o2 / .h: partie haute de l'octet, .l: partie basse de l'octet)
Liaison série 8 bits + 1 bit start (0) + 2 bits stop (1) / pas de bit de parité / bit de poids faible en premier
Au niveau du câble: Vcc=0 (par défaut), GND=1
Liaison clavier->Microcontrôleur 600 Baud
Microcontrôleur->Liaison clavier 300 Baud

y: bit non utilisé / inconnu
xxxx (o1.h): bits de détection d'erreur 
o1.h=(o1.l+o2.h+o2.l)&0x0F

Transfert d'état des touches :
	o1: xxxxa0y0
	o2: bcdefgh1

	a: 0=pressé 0=relâché

	donnée transférée: bcdefgh(!a)

	Liste des touches et o2:

		6 0x11
	 volume - 0x13
	      Bis 0x15
		2 0x17
		4 0x19
		8 0x1B
		# 0x1D
		* 0x1F
		3 0x21
	 volume + 0x23
	      …/… 0x25
		1 0x27
		5 0x29
		7 0x2B
		9 0x2D
		0 0x2F
	      Mem 0x31
 appel répertoire 0x33
     haut parleur 0x35
		) 0x37
	   entrée 0x39
		M 0x3B
		: 0x3D
    flèche droite 0x3F

   appel annuaire 0x45

		ç 0x51

	   on/off 0x55
		P 0x57
		L 0x59
      flèche haut 0x5B
    flèche gauche 0x5D
       flèche bas 0x5F
		! 0x61
	    Envoi 0x63
       Répétition 0x65
		I 0x67
		O 0x69
		K 0x6B
		; 0x6D
		, 0x6F
		è 0x71
	    Suite 0x73
	   Retour 0x75
		U 0x77
		J 0x79
		N 0x7B
		B 0x7D
	   espace 0x7F
		- 0x81
       Correction 0x83
       Annulation 0x85
		Y 0x87
		H 0x89
		G 0x8B
		C 0x8D
		V 0x8F
		( 0x91
	    Guide 0x93
	 Sommaire 0x95
		T 0x97
		F 0x99
		X 0x9B
	     Ctrl 0x9D
	  Min/Maj 0x9F
		' 0xA1
	     Fnct 0xA3
	      Esc 0xA5
		" 0xA7
		R 0xA9
		D 0xAB
		W 0xAD
	    shift 0xAF
		é 0xB1
		& 0xB3
       Connex/Fin 0xB5
		Z 0xB7
		E 0xB9
		A 0xBB
		S 0xBD
		Q 0xBF

		à 0xD3
		

Commande système - changement d'état? :
	o1: xxxxy1y0
	o2: abcdefg1

	Exemples:
		Réponse au bouton off: uc: 0x94 0x23 / (attente) / uc: 0x14 0x2B
		Réponse au bouton on: uc: 0x14 0x2B 0x94 0x23
		Décrochage du téléphone - pas de ligne: clavier: 0x5C 0x63 / uc: 0xF4 0x29
		Raccrochage du téléphone - pas de ligne: clavier: 0x3C 0x61 / uc: 0x74 0x03 0x74 0x03 0x74 0x21
		Chaque minute - demande d'état du téléphone?: uc: 0xC4 0x17 / clavier: 0x3C 0x61 (racroché) ou 0x5C 0x63 (décroché) ou 0xFC 0x21 (racroché haut parleur)
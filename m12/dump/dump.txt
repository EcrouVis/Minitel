Dump de la mémoire d'un minitel M12 Philips.
Le dump est en 4 parties car pour accéder à toute la mémoire de la ROM, le minitel n'a pas un bus de données assez large (processeur 80C32) et utilise donc 2 GPIOs (P1.0 et P1.1) pour changer de 'banque de données' et ainsi pouvoir lire toute la mémoire.

Notez que ce système a partiellement endomagé ma puce mémoire.
Les 2 entrées d'adresse gérées de manière externe par le circuit électronique et censées accepter un signal TTL se sont dégradées au point où 3.3V n'était plus considéré comme un 1 mais comme à un niveau indéfini!

Chaque banque semble formée de la même manière:

|---------------------------------------|
|Code d'initialisation/Reset            |
|Vecteurs d'interruption                |
|---------------------------------------|
|Code spécifique à la banque            |
|---------------------------------------|
|0xE000 - 0xE614:                       |
|Fonctions de saut vers d'autres banques|
|---------------------------------------|
|???                                    |
|---------------------------------------|

---------- Commun à toutes les banques ----------

Fonctions de saut de banque:

-vers p1:
  0xE2C0 - 0xE608
  105 fonctions

-vers p2:
  0xE000 - 0xE2C0
  88 fonctions

-vers p3:
  0xE608 - 0xE614
  1 fonction - lecteur de l'audio du répondeur minitel

-vers p4:
  rien

Exemple de fonction de saut (adresse 0xE000):

dump_Bz6_p1.bin:
  e000:
  SETB P1.0
  LCALL e000
  CLR P1.0
  RET

dump_Bz6_p2.bin:
  SETB P1.0
  LCALL 07fe
  CLR P1.0
  RET

---------- ROM partie 1 (dump_Bz6_p1.bin) ----------

En cours de décompilation

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut
  -d'autres fonctions

---------- ROM partie 2 (dump_Bz6_p2.bin) ----------

En cours de décompilation

Contient le protocole ?

Contient énormément d'instructions JMP

Il faut désactiver l'analyse des switch/case dans Ghidra et faire la décompilation des JMP manuellement pour ne pas avoir de problèmes lors de la décompilation.

---------- ROM partie 3 (dump_Bz6_p3.bin) ----------

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut
  -le lecteur audio
  -la piste audio

Code du lecteur audio:
  0x966B - 0x96B3

Audio du répondeur minitel:
  0x01D1 - 0x9542
  Audio sous forme PWM puis filtré (passe bande 300-3400Hz pour la téléphonie)
  Le bit de poids fort est lu en premier
  L'oscillateur a une période de 14.7456MHz
  1 bit est joué toutes les 27.5*12 périodes en moyenne

Code non utilisé:
  0x0008 - 0x000A:
    Fin des données audio

  0x9542 - 0x95E2

  0x96D3 - 0x96E8
    Copie la ROM (partie 3 seulement) dans la RAM externe puis s'arrête (boucle infinie)

  0xFFAD - 0xFFF1
    Checksum sur 16 bit de la ROM entière puis envoi le résultat quelque part en base 16

---------- ROM partie 4 (dump_Bz6_p4.bin) ----------

Ne semble pas être utilisée

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut

Code non utilisé:
  0x01D1 - 0x0271

  0x031A - 0x032F
    Copie la ROM (partie 4 seulement) dans la RAM externe puis s'arrête (boucle infinie)

  0xFFAD - 0xFFF1:
    Checksum sur 16 bit de la ROM entière puis envoi le résultat quelque part en base 16



---------- Partage du bus de données entre la ROM, la RAM, la puce vidéo et le CPLD MBSL-4000FH5-5 ----------

Quand P1.5=1, la ROM et la RAM externe sont accédées de manière normale. On peut supposer que le CPLD fait office de tampon pour les 8 bits de poids fort de l'adresse.

Quand P1.5=0, la puce vidéo est virtuellement montée aux adresses 0xXX20 à 0xXX2F à la place de la RAM externe. On peut supposer que les autres entrées sorties du CPLD peuvent être accédées de la même manière mais à d'autres adresses.

De potentielles adresses (en recherchant la séquence 0xC2 0x95 - CLR P1.5 dans la ROM partie 1 et 2) utilisées pour communiquer avec le CPLD sont:
0x0040
0x0041
0x0042
0x0048
0x0050
0x0051
0x0052
0x0053
0x0070



---------- Emulation de la liaison série microcontrôleur - modem ----------
RX:

Le timer augmente de 1 à une fréquence de f_osc/12 et déborde à une fréquence de f_osc/12/256
Cela donne une vitesse de réception de f_osc/(i2C.5?196608:12288) bauds (soit 75/1200 bauds avec un oscillateur de 14.7456MHz)

Forme du message: 1 start bit + 8 bits + 2 stops bits

Variables gérées en interne:
i7D: x bits restants
i7B: pause x cycle
i7C: message en cours de réception
i26.5: message détecté
i26.6: réessayer de réceptionner le message si erreur sur le premier bit stop

Variables de contrôle de la réception:
i75: message non lu reçu
i76: message non lu reçu précédent
i2C.5: vitesse de réception 0: 1200 bauds / 1: 75 bauds
i22.0: message présent
i22.1: quel message à écraser en cas de nouvelle réception 0: nouveau / 1: ancien
i29.3: message précédent écrasé

MAIN
  TMOD=0x23 //timer 1: 8-bit contrôlé par TH0 (timer 0 en mode 3) avec rechargement automatique / timer 0: 8-bit
  TCON=0x50

IE1
  if INT1 return
  clear EX1 //désactivation de l'interruption
  TH0=0x0F //ajustement de la valeur de départ du timer
  clear TF1 //remise à zéro de l'interruption du timer
  set ET1 //activation du timer
  set i26.5 //initialisation de la réception du message
  set i26.6
  i7D=8
  i7B=2
  if i2C.5 //dans le cas de la réception à 75 bauds
    TH0=0x13
    i7B=0x20
  return

IT1
  i7B-=1
  if i7B>0 return //attends le prochain bit
  i7B=4 //prochain bit dans 4 cycles
  if i2C.5 i7B=0x40
  if i26.5 //dans le cas où un message est détecté
    i7C=(i7C>>1)|(INT1?0x80:0)
    i7D-=1
    if i7D==0:
      clear i26.5 //fin du message
    return
  if i26.6
    clear i26.6
    if not INT1 //erreur dans la réception du premier bit stop, réessayer
      set i26.5
      return
  else
    if INT1 //transfert du message + flags
      if i22.1
        i76=i75
        set i29.3
      else
        set i22.1
      i75=i7C
      set i22.0
  clear ET1 //désactivation du timer
  set EX1 //activation de l'interruption
  return

TX:

L'utilisation d'IT0 est partagé avec une autre fonction qui n'est pas pris en compte ci-dessous pour plus de simplicité

Variables gérées en interne:
i7A: compteur pause x cycles (4800->1200 cycles par secondes)
i7E: compteur division des cycles par x (1200->75 cycles par secondes)
i78: message en cours d'émission

Variables de contrôle de l'émission:
i24.6: émission du message en cours
i24.7: message non envoyé présent
i26.3: émission du message quand 0
i26.4: message à envoyer présent
i26.0,i26.1,i26.2: x bits envoyés
i28.0: vitesse d'émission 0: 75 bauds / 1: 1200 bauds
i79: message à envoyer

MAIN
  TMOD=0x23
  TCON=0x50

F_TX //dans la partie 2 de la ROM à l'adresse 0x70C6
  i79=A //message à envoyer
  set i24.7 //message présent
  if not i24.6 //réinitialisation des variables
    i26|=0x18
  set i24.6

IT0
  i7A-=1
  if i7A>0 return
  i7A=4
  if not i24.6 return
  if not 28.0 //dans le cas d'un envoi à 75 bauds
    i7E-=1
    if i7E return //ne laisser passer qu'un cycle sur 16 (1200/75=16)
    i7E=0x10
  if i26.3
    clear i26.3
    if i26.4
      clear i26.4
      i78=i79
      clear i24.7
      clear P1.3 //start bit
      return
    i26|=0x18
    if not i24.7
      set P1.3 //stop bit
      clear i24.6
      return
  else
    A=(i78>>1)|(i78<<7)&0xFF
    i26+=1
    B=i78&0x01
    i78=A
    if B: //envoi d'un bit du message
      set P1.3
    else
      clear P1.3

Changement de vitesse:

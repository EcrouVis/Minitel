Dump de la mémoire d'un minitel M12 Philips.
Le dump est en 4 parties car pour accéder à toute la mémoire de la ROM, le minitel n'a pas un bus de données assez large (processeur 80C32) et utilise donc 2 GPIOs (P1.0 et P1.1) pour changer de 'banque de données' et ainsi pouvoir lire toute la mémoire.

Notez que ce système a partiellement endomagé ma puce mémoire.
Les 2 entrées d'adresse gérées de manière externe par le circuit électronique et censées accepter un signal TTL se sont dégradées au point où 3.3V n'était plus considéré comme un 1 mais comme à un niveau indéfini!

Chaque banque semble formée de la même manière:

|---------------------------------------|
|Code d'initialisation/Reset            |
|Vecteurs d'interruption                |
|---------------------------------------|
|Code spécifique à la banque            |
|---------------------------------------|
|0xE000 - 0xE614:                       |
|Fonctions de saut vers d'autres banques|
|---------------------------------------|
|???                                    |
|---------------------------------------|

---------- Commun à toutes les banques ----------

Fonctions de saut de banque:

-vers p1:
  0xE2C0 - 0xE608
  105 fonctions

-vers p2:
  0xE000 - 0xE2C0
  88 fonctions

-vers p3:
  0xE608 - 0xE614
  1 fonction - lecteur de l'audio du répondeur minitel

-vers p4:
  rien

Exemple de fonction de saut (adresse 0xE000):

dump_Bz6_p1.bin:
  e000:
  SETB P1.0
  LCALL e000
  CLR P1.0
  RET

dump_Bz6_p2.bin:
  SETB P1.0
  LCALL 07fe
  CLR P1.0
  RET

---------- ROM partie 1 (dump_Bz6_p1.bin) ----------

En cours de décompilation

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut
  -d'autres fonctions

---------- ROM partie 2 (dump_Bz6_p2.bin) ----------

En cours de décompilation

Contient le protocole ?

Contient énormément d'instructions JMP

Il faut désactiver l'analyse des switch/case dans Ghidra et faire la décompilation des JMP manuellement pour ne pas avoir de problèmes lors de la décompilation.

---------- ROM partie 3 (dump_Bz6_p3.bin) ----------

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut
  -le lecteur audio
  -la piste audio

Code du lecteur audio:
  0x966B - 0x96B3

Audio du répondeur minitel:
  0x01D1 - 0x9542
  Audio sous forme PWM puis filtré (passe bande 300-3400Hz pour la téléphonie)
  Le bit de poids fort est lu en premier
  L'oscillateur a une période de 14.7456MHz
  1 bit est joué toutes les 27.5*12 périodes en moyenne

Code non utilisé:
  0x0008 - 0x000A:
    Fin des données audio

  0x9542 - 0x95E2

  0x96D3 - 0x96E8

  0xFFAD - 0xFFF1
    Checksum sur 16 bit de la ROM entière puis envoi le résultat quelque part en base 16

---------- ROM partie 4 (dump_Bz6_p4.bin) ----------

Ne semble pas être utilisée

Contient:
  -la fonction d'initialisation
  -les vecteurs d'interruptions
  -la table de saut

Code non utilisé:
  0x01D1 - 0x0271

  0x031A - 0x032F

  0xFFAD - 0xFFF1:
    Checksum sur 16 bit de la ROM entière puis envoi le résultat quelque part en base 16




---------- Emulation de la liaison série microcontrôleur - modem ----------
RX:

forme du message: 1 start bit + 8 bits + 2 stops bits

variables gérées en interne:
i7D: x bits restants
i7B: pause x cycle
i7C: message en cours de réception
i26.5: message détecté
i26.6: réessayer de réceptionner le message si erreur sur le premier bit stop

variable de contrôle de la réception:
i75: message non lu reçu
i76: message non lu reçu précédent
i2C.5: vitesse de réception 0: 1200 bauds / 1: 75 bauds
i22.0: message présent
i22.1: quel message à écraser en cas de nouvelle réception 0: nouveau / 1: ancien
i29.3: message précédent écrasé

MAIN
  TMOD=0x23
  TCON=0x50

IE1
  if INT1 return
  clear EX1 //désactivation de l'interruption
  TH0=0x0F
  clear TF1 //remise à zéro de l'interruption du timmer
  set ET1 //activation du timmer
  set i26.5 //initialisation de la réception du message
  set i26.6
  i7D=8
  i7B=2
  if i2C.5 //dans le cas de la réception à 75 bauds
    TH0=0x13
    i7B=0x20
  return

IT1
  i7B-=1
  if i7B>0 return //attends le prochain bit
  i7B=4 //prochain bit dans 4 cycles
  if i2C.5 i7B=0x40
  if i26.5 //dans le cas où un message est détecté
    i7C=(i7C>>1)|(INT1?0x80:0)
    i7D-=1
    if i7D==0:
      clear i26.5 //fin du message
    return
  if i26.6
    clear i26.6
    if not INT1 //erreur dans la réception du premier bit stop, réessayer
      set i26.5
      return
  else
    if INT1 //transfert du message + flags
      if i22.1
        i76=i75
        set i29.3
      else
        set i22.1
      i75=i7C
      set i22.0
  clear ET1 //désactivation du timmer
  set EX1 //activation de l'interruption
  return

TX:

MAIN

F_TX

IT0
  
